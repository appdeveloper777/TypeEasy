{"prompt": "Necesito añadir una forma de imprimir valores en la consola. Quiero dos comandos: 'print' para imprimir sin salto de línea, y 'println' para imprimir con salto de línea. Ambos deben tomar una expresión entre paréntesis como argumento y terminar con un punto y coma.", "completion": {"parser_l_additions": ["\"print\"                 { return PRINT; }", "\"println\"               { return PRINTLN; }"], "parser_y_additions": {"tokens": "%token PRINT PRINTLN", "rules": ["statement: PRINT LPAREN expression RPAREN SEMICOLON                    { $$ = create_ast_node(\"PRINT\", $3, NULL); }", "         | PRINTLN LPAREN expression RPAREN SEMICOLON                    { $$ = create_ast_node(\"PRINTLN\", $3, NULL); }"]}, "ast_h_additions": [], "ast_c_additions_skeleton": ["// El nodo genérico create_ast_node ya maneja la creación.", "// La lógica de interpretación para los tipos 'PRINT' y 'PRINTLN' debe ser añadida.", "void interpret_ast(ASTNode *node) {", "    if (!node) return;", "    if (strcmp(node->type, \"PRINT\") == 0) {", "        // TODO: Implementar la lógica para evaluar node->left e imprimir en consola.", "    } else if (strcmp(node->type, \"PRINTLN\") == 0) {", "        // TODO: Implementar la lógica para evaluar node->left e imprimir con salto de línea.", "    }", "    // ... resto de la función interpret_ast ...", "}"]}}
{"prompt": "Quiero una sintaxis para declarar variables inmutables con la palabra clave 'let'. Debe seguir el formato 'let nombre = expresion;'.", "completion": {"parser_l_additions": ["\"let\"                   { return LET; }"], "parser_y_additions": {"tokens": "%token LET", "rules": ["var_decl: LET IDENTIFIER ASSIGN expression SEMICOLON  { $$ = create_var_decl_node($2, $4); }"]}, "ast_h_additions": ["ASTNode *create_var_decl_node(char *id, ASTNode *value);"], "ast_c_additions_skeleton": ["ASTNode *create_var_decl_node(char *id, ASTNode *value) {", "    ASTNode *node = create_ast_node(\"VAR_DECL\", value, NULL);", "    node->id = strdup(id);", "    return node;", "}", "void interpret_var_decl_node(ASTNode *node) {", "    // TODO: Implementar la lógica para almacenar la variable 'node->id' con el valor evaluado de 'node->left' en la tabla de símbolos.", "}"]}}
{"prompt": "Necesito una sintaxis para definir clases. Debe usar la palabra clave 'class', seguida de un nombre. El cuerpo de la clase debe estar entre llaves y puede contener miembros.", "completion": {"parser_l_additions": ["\"class\"                 { return CLASS; }"], "parser_y_additions": {"tokens": "%token CLASS", "rules": ["class_decl: CLASS IDENTIFIER LBRACKET class_body RBRACKET { $$ = NULL; }"]}, "ast_h_additions": ["typedef struct ClassNode {", "    char *name;", "    Variable *attributes;", "    int attr_count;", "    MethodNode *methods;", "    struct ClassNode *next;", "} ClassNode;", "ClassNode *create_class(char *name);", "void add_class(ClassNode *class);"], "ast_c_additions_skeleton": ["ClassNode *create_class(char *name) {", "    ClassNode *cls = malloc(sizeof(ClassNode));", "    cls->name = strdup(name);", "    cls->attributes = NULL;", "    cls->attr_count = 0;", "    cls->methods = NULL;", "    cls->next = NULL;", "    return cls;", "}", "void add_class_to_global_list(ClassNode *class) {", "    // TODO: Implementar la lógica para añadir la nueva clase a una lista global de clases disponibles.", "}"]}}
{"prompt": "Quiero añadir un bucle 'for' de estilo C. Debe tener un inicializador (asignación simple), una condición de continuación y una expresión de incremento (simple, ej. i = i + 1), seguido de un cuerpo de sentencias entre llaves.", "completion": {"parser_l_additions": ["\"for\"                   { return FOR; }"], "parser_y_additions": {"tokens": "%token FOR", "rules": ["statement: FOR LPAREN IDENTIFIER ASSIGN NUMBER SEMICOLON expression SEMICOLON expression RPAREN LBRACKET statement_list RBRACKET  { $$ = create_ast_node_for(\"FOR\", create_ast_leaf(\"IDENTIFIER\",0,NULL,$3), create_ast_leaf(\"NUMBER\",$5,NULL,NULL), $7, $9, $12); }"]}, "ast_h_additions": ["ASTNode *create_ast_node_for(char *type, ASTNode *var, ASTNode *init, ASTNode *condition, ASTNode *update, ASTNode *body);"], "ast_c_additions_skeleton": ["ASTNode *create_ast_node_for(char *type, ASTNode *var, ASTNode *init, ASTNode *condition, ASTNode *update, ASTNode *body) {", "    ASTNode* node = create_ast_node(type, var, init);", "    node->right = condition;", "    node->next = update;", "    node->extra = body;", "    return node;", "}", "void interpret_for_node(ASTNode *node) {", "    // TODO: Implementar la lógica del bucle for:", "    // 1. Ejecutar la inicialización.", "    // 2. Mientras la condición sea verdadera:", "    //    a. Ejecutar el cuerpo.", "    //    b. Ejecutar la actualización.", "}"]}}
{"prompt": "Necesito una sintaxis para definir modelos de machine learning. La palabra clave debe ser 'model', seguida de un nombre, y un cuerpo entre llaves que contendrá una lista de capas.", "completion": {"parser_l_additions": ["\"model\"      { yylval.sval = strdup(yytext); return MODEL; }"], "parser_y_additions": {"tokens": "%token MODEL", "rules": ["statement: MODEL IDENTIFIER LBRACKET layer_list RBRACKET { $$ = create_model_node($2, $4); }"]}, "ast_h_additions": ["ASTNode* create_model_node(const char* model_name, ASTNode* layer_list);"], "ast_c_additions_skeleton": ["ASTNode* create_model_node(const char* model_name, ASTNode* layer_list) {", "    ASTNode* node = create_ast_node(\"MODEL\", layer_list, NULL);", "    node->id = strdup(model_name);", "    return node;", "}", "void interpret_model_node(ASTNode *node) {", "    // TODO: Implementar la lógica para registrar un nuevo modelo de ML en el sistema.", "    // El nombre del modelo es node->id.", "    // La lista de capas está en node->left.", "}"]}}